import * as fs from 'fs';
import * as path from 'path';
import { privOwner, privUser } from '../sql_to_fnc.constans';
import { FieldDefinition } from './sql_to_fnc.interfaces';
import { isString } from './common';

const header = '-- Generated by sql_to_fnc';
/**
 * SQL functions GET, DELETE, LIST, SAVE create
 */

function getFunctionList(arr: FieldDefinition[]): string {
  let fieldList = '';
  arr.forEach((item) => {
    fieldList += `          ${item.field},\n`;
  });
  return fieldList.slice(0, -2);
}

function getFieldArray(arr: FieldDefinition[]): string {
  let result = '';
  arr.forEach((item) => {
    if (isString(item)) {
      if (result !== '') { result += ','; }
      result += '"' + item.field + '"';
    }
  });

  return result;
}

function sqlData(elem: FieldDefinition): string {
  switch (elem.type) {
    case 'BOOLEAN':
    case 'BOOL':
      return `COALESCE( cast( f_data->>'${elem.field}' as boolean), true)`;
    case 'DATE':
    case 'TIMESTAMPTZ':
    case 'TIMESTAMP':
    case 'INT4':
    case 'INT8':
    case 'INTEGER':
      return `CAST( f_data->>'${elem.field}' as ${elem.type})`;
    case 'VARCHAR':
    case 'BPCHAR':
    default:
      return `f_data->>'${elem.field}'`;
  }
}

function generateGet(
  schemaName: string,
  tblName: string,
  sequenceName: string,
  fieldArray: FieldDefinition[],
) {
  /**
   *     GET
   */
  let getFncName = `fnc_${schemaName}.${tblName}_get`;
  if (schemaName === 'public') {
    getFncName = `fnc_${tblName}_get`;
  }
  const sqlGet = `${header}
CREATE OR REPLACE FUNCTION ${getFncName}(a_id integer)
  RETURNS TEXT AS
$BODY$
BEGIN
  RETURN to_jsonb( u ) FROM (
    SELECT
${getFunctionList(fieldArray)} 
     FROM ${schemaName}.${tblName}
    WHERE ${fieldArray[0].field} = a_id
  ) as u;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
                   COST 100;
COMMENT ON FUNCTION ${getFncName}(integer) IS 'Get ${tblName}';
ALTER FUNCTION ${getFncName}(integer) OWNER TO ${privOwner};
GRANT EXECUTE ON FUNCTION ${getFncName}(integer) TO ${privUser};
`;
  fs.writeFileSync(path.join('dist', 'sql', `${getFncName}.sql`), sqlGet);
}

function generateDelete(
  schemaName: string,
  tblName: string,
  sequenceName: string,
  fieldArray: FieldDefinition[],
) {
  /**
   *    DELETE
   */
  let delFncName = `fnc_${schemaName}.${tblName}_delete`;
  if (schemaName === 'public') {
    delFncName = `fnc_${tblName}_delete`;
  }
  const sqlDelete = `${header}
CREATE OR REPLACE FUNCTION ${delFncName}( a_id integer )
  RETURNS TEXT AS
$BODY$
BEGIN
  PERFORM 1 FROM ${schemaName}.${tblName} WHERE ${fieldArray[0].field} = a_id;
  IF NOT FOUND THEN
    RETURN jsonb_build_object('error', 'Item not exist', 'code', 404);
  END IF;
  BEGIN
    DELETE FROM ${schemaName}.${tblName} WHERE ${fieldArray[0].field} = a_id;
  EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object('error', 'Cannot delete item', 'code', 403);
  END;
  RETURN jsonb_build_object('code', 202 );
END;
$BODY$
LANGUAGE plpgsql VOLATILE
                   COST 100;
ALTER FUNCTION ${delFncName}(integer) OWNER TO ${privOwner};
GRANT EXECUTE ON FUNCTION ${delFncName}(integer) TO ${privUser};`;
  fs.writeFileSync(path.join('dist', 'sql', `${delFncName}.sql`), sqlDelete);
}

function generateList(
  schemaName: string,
  tblName: string,
  sequenceName: string,
  fieldArray: FieldDefinition[],
) {

  /**
   *    LIST
   */
  let listFncName = `fnc_${schemaName}.${tblName}_list`;
  if (schemaName === 'public') {
    listFncName = `fnc_${tblName}_list`;
  }
  const sqlList = `${header}
CREATE OR  REPLACE FUNCTION ${listFncName}(a_filter character varying)
  RETURNS TEXT AS
$BODY$
DECLARE
  f_request   jsonb;
  f_filter    jsonb; -- "filter":[{"field": "login", "value": "John%"}]
  f_p_size    integer;
  f_p_offset  integer;
  f_order     varchar;  -- asc/desc
  f_sort      varchar; -- "sort": ["login", "active"]
  f_sql       varchar;
  f_result    jsonb;
  f_cnt       integer;
  f_sql_where varchar;
  f_sql_order varchar;
  f_sql_cnt   varchar;
  f_valid_search_fields varchar[];
  f_filter_field_type varchar;
BEGIN
  f_valid_search_fields = '{${getFieldArray(fieldArray)}}'::varchar[];
  f_request = CAST(a_filter as jsonb);
  f_p_size = (f_request->>'page_size')::integer;
  f_p_offset = (f_request->>'page_index')::integer * f_p_size;
  f_order = f_request->>'sort_direction';
  IF (NOT ((f_order='asc') OR (f_order='desc') OR (f_order=''))) THEN
    RETURN jsonb_build_object('error','Wrong order', 'code', 400);
  END IF;

  f_sql_where = '';
  FOR f_filter IN
    SELECT * FROM jsonb_array_elements( f_request->'filter' )
  LOOP
    IF NOT CAST(f_filter->>'field' as varchar) = ANY (f_valid_search_fields) THEN
      RETURN jsonb_build_object('error','Wrong filter field', 'code', 400);
    END IF;
    SELECT data_type
      INTO f_filter_field_type
      FROM information_schema.columns
     WHERE table_name = '${tblName}'
       AND table_schema = '${schemaName}'
       AND column_name = CAST(f_filter->>'field' as varchar);
    IF f_filter_field_type = 'character varying' THEN
      f_sql_where = f_sql_where || ' AND upper(' || CAST(f_filter->>'field' as varchar) || ') LIKE ' || quote_literal(upper(f_filter->>'value'));
    ELSEIF f_filter_field_type = 'boolean' THEN
      f_sql_where = f_sql_where || ' AND ' || CAST(f_filter->>'field' as varchar) || ' = ' || CAST(f_filter->>'value' as varchar);
    ELSE
      RETURN jsonb_build_object('error','Wrong filter field type', 'code', 400);
    END IF;
  END LOOP;

  f_sql_order = '';
  FOR f_sort IN
    SELECT * FROM jsonb_array_elements_text( f_request->'sort')
  LOOP
    IF NOT CAST(f_sort as varchar) = ANY (f_valid_search_fields) THEN
      RETURN jsonb_build_object('error','Wrong sort field', 'code', 400);
    END IF;
    IF (f_sql_order = ''::varchar) THEN
      f_sql_order = f_sql_order || f_sort;
    ELSE
      f_sql_order = f_sql_order || ',' || f_sort;
    END IF;
  END LOOP;
  IF (f_sql_order <> '') THEN
    f_sql_order = ' ORDER BY ' || f_sql_order || ' ' || f_order;
  END IF;

   f_sql = format('SELECT COALESCE(to_jsonb(array_agg( u )),''[]''::jsonb) FROM (
    SELECT
${getFunctionList(fieldArray)}
    FROM ${schemaName}.${tblName}
    WHERE TRUE %s
    %s
    LIMIT $1
    OFFSET $2
  ) as u', f_sql_where, f_sql_order);
  EXECUTE f_sql INTO f_result USING f_p_size, f_p_offset;
  f_sql_cnt = format('SELECT count(*) FROM ${schemaName}.${tblName} WHERE TRUE %s', f_sql_where);
  EXECUTE f_sql_cnt INTO f_cnt;
  RETURN jsonb_build_object('data', f_result, 'cnt', f_cnt);
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
                   COST 100;
COMMENT ON FUNCTION ${listFncName}(character varying) IS 'List';
ALTER FUNCTION ${listFncName}(character varying) OWNER TO ${privOwner};
GRANT EXECUTE ON FUNCTION ${listFncName}(character varying) TO ${privUser};
`;
  fs.writeFileSync(path.join('dist', 'sql', `${listFncName}.sql`), sqlList);
}

function generateSave(
  schemaName: string,
  tblName: string,
  sequenceName: string,
  fieldArray: FieldDefinition[],
) {

  /**
   *       SAVE
   */
  let saveFncName = `fnc_${schemaName}.${tblName}_save`;
  if (schemaName === 'public') {
    saveFncName = `fnc_${tblName}_save`;
  }
  let sqlSave = `${header}
CREATE OR REPLACE FUNCTION ${saveFncName}( a_data character varying )
    RETURNS text AS
$BODY$
DECLARE
  f_id    integer;
  f_data  jsonb;
BEGIN
  f_data = a_data::jsonb;
  f_id   = COALESCE( CAST( f_data->>'${fieldArray[0].field}' as INTEGER ), 0);

  IF f_id > 0 THEN
      PERFORM 1 FROM ${schemaName}.${tblName} WHERE ${fieldArray[0].field} = f_id;
      IF NOT FOUND THEN
        RETURN jsonb_build_object('error', 'Item not exist', 'code', 404);
      END IF;
      UPDATE ${schemaName}.${tblName} SET \n`;

  fieldArray.forEach((item) => {
    if (item.field === fieldArray[0].field) { return; }
    sqlSave += `            ${item.field} = ${sqlData(item)},\n`;
  });
  sqlSave = sqlSave.slice(0, -2);
  sqlSave += `
      WHERE ${fieldArray[0].field} = f_id;
  ELSE
      f_id = nextval('${sequenceName}'::regclass);
      INSERT INTO ${schemaName}.${tblName} (
${getFunctionList(fieldArray)}
      ) VALUES (
          f_id,\n`;
  // Copy and remove first element (id), already filled as f_id
  let insertArray: FieldDefinition[] = JSON.parse(JSON.stringify(fieldArray));
  insertArray.shift();
  insertArray.forEach((item) => {
    sqlSave += `          ${sqlData(item)},\n`;
  });
  sqlSave = sqlSave.slice(0, -2);
  sqlSave += `
      );
  END IF;

  RETURN jsonb_build_object('id', f_id, 'code', 200 );
END;
$BODY$
    LANGUAGE plpgsql VOLATILE
                     COST 100;
ALTER FUNCTION ${saveFncName}(character varying) OWNER TO ${privOwner};
GRANT EXECUTE ON FUNCTION ${saveFncName}(character varying) TO ${privUser};
`;
  fs.writeFileSync(path.join('dist', 'sql', `${saveFncName}.sql`), sqlSave);
}

export function generateSQL(
  schemaName: string,
  tblName: string,
  sequenceName: string,
  fieldArray: FieldDefinition[],
) {
  if (!fs.existsSync(path.join('dist', 'sql'))) {
    fs.mkdirSync(path.join('dist', 'sql'), { recursive: true });
  }

  generateGet(schemaName, tblName, sequenceName, fieldArray);

  generateDelete(schemaName, tblName, sequenceName, fieldArray);

  generateList(schemaName, tblName, sequenceName, fieldArray);

  generateSave(schemaName, tblName, sequenceName, fieldArray);

}
